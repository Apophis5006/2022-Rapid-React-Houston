/*----------------------------------------------------------------------------*/
/* Copyright (c) 2018 FIRST. All Rights Reserved.                             */
/* Open Source Software - may be modified and shared by FRC teams. The code   */
/* must be accompanied by the FIRST BSD license file in the root directory of */
/* the project.                                                               */
/*----------------------------------------------------------------------------*/
#define CALSWERVE  //Move all gears to left side of robot and then read the Zero values for table
//#define CALHOOD
//#define PIDTUNE


//#define NOBALLEJECT
//#define DISP_ENCODER_VALS
//#define STOPSHOOTERSPIN

#define ENCODER_VALS
#include <stdio.h>
#include <frc/Joystick.h>
#include <frc/DigitalInput.h>
#include <frc/TimedRobot.h>
#include <frc/Timer.h>
#include "ctre/Phoenix.h"
#include <opencv2/core/core.hpp>
#include <opencv2/core/types.hpp>
#include <opencv2/imgproc/imgproc.hpp>
#include <thread>
#include "networktables/NetworkTable.h"
#include "networktables/NetworkTableInstance.h"
#include <vector>

#include <frc/PneumaticsControlModule.h>
#include <frc/Solenoid.h>
#include <frc/smartdashboard/SmartDashboard.h>
#include "ahrs.h" //https://www.kauailabs.com/public_files/navx-mxp/apidocs/c++/

#include "frc/DriverStation.h"

//color sensor
#include <frc/util/color.h> 
#include "rev/ColorSensorV3.h"
#include "rev/ColorMatch.h"

//LimeLight Defines

#define TARGET 0
#define CAMERA 1 
#define TARGET_ABOVE_CAMERA	88    //83	// Vertical Distance from camera to center of reflective tape = 6.33 ft
#define GOAL_ABOVE_SHOOTER	83	// Vertical Distance from shooter to center of upper goal = 6.00 ft
#define ADD_TO_INNER_GOAL	27	// Horizontal Distance from outer goal to inner goal = 2'5.25"
#define CAMERA_ANGLE	    35 //40	// Angle (Pitch) of mounted camera
std::shared_ptr<nt::NetworkTable> table = nt::NetworkTableInstance::GetDefault().GetTable("limelight");
double targetOffsetAngleHorizontal = table->GetNumber("tx",0.0);
double targetOffsetAngleVertical = table->GetNumber("ty",0.0);
double targetArea = table->GetNumber("ta",0.0);


#define TIMEOUT 10
#define NOTIMEOUT 0
#define TRUE 1
#define FALSE 0

#ifdef ENCODER_VALS  
  float TestF=0.0;
  int nokey=0;
#endif  

int Initialized = 0;
int HoodInitialized=0;

//Intake variables
int IntakeIsDown = 0;
int Magazine_On = 0;
int Intake_On=0;
int AutoShootState=0;
double Drive_Speed_Target=0;

//Shooter Variables
int Shooter_On = 0, Shooter_Trigger_On = 0, ShooterState = 00;
float Shooter_Speed_Target = 0;
int WasTelop=0, WasAuto=0;
int HoodTarget=0,HoodLocation, HoodMax=0,CalcHoodTarget;
float ShooterVelocity=0;
int TriggerRunning=0;

//Joystick defines
#define DIR 0
#define ROT 1
#define ARM 2

//#define PVALUE 1.0
//-------------------CAN BUS DEFINES---------------
//Swerve CAN bus defines for steering motors
#define FLS 4
#define FRS 1
#define RRS 3
#define RLS 2
//Swerve CAN bus defines for drive motors
#define FLD 15
#define FRD 12
#define RLD 13
#define RRD 14
//CAN Bus defines for intake motor
#define INTAKE 8
#define MAGAZINE 7
#define TRIGGER 5
#define HOOD 6
#define SHOOTER 11

//For swerve code, define motor data locations in the arrays
#define RR 0
#define FR 1
#define FL 2
#define RL 3
#define ALL -1 /* all drive channels */
#define IDX  3 /* use Rear Left Wheel as index */
#define PI 3.141592654
#define ENCODER_RES_FL 4179.0 //4156.0 //4180.0
#define ENCODER_RES_RL 4152.0 //4185.0 //4180.0
#define ENCODER_RES_FR 4154.0 //4076.0 //4180.0
#define ENCODER_RES_RR 4162.0 //4175.0 //4180.0
#define SW_L 19.0      //18.75   //Distance between wheels from front to back
#define SW_W 18.875   //18.75  //Distance between wheels from side to side


#define STATE_HOLD 0
#define STATE_FILL_MAGAZINE 1
#define STATE_TRIGGER 2
#define STATE_END 3
//#define STATE_EJECT 4


int TeleStarted=1;
int FieldCentric=0;   //1= feild centric driving
float RobotAngle=0.0; //angle from Gyro
int UpdateCount=0;    //counter to slow screen update so it does not take too many CPU cycles
int AutoTargeting=0;
float DistanceToGoal=0;
int hoodPercent=0;

//Swerve Control variables  RR, FR, FL, RL
float SpeedPolarity[4]={1.0,1.0,1.0,1.0}; //which way is forward on wheels (switches to speed up swerve rotations)
float ActDir[4]={0.0,0.0,0.0,0.0};        //storage for actual angles of wheel from motor controller encoder feedback
#ifdef CALSWERVE
float ZeroDir[4]={0.0,0.0,0.0,0.0};  //storage for adjustment of actual angles of wheel from motor controller encoder feedback
#else
//float ZeroDir[4]={-67.0,119.0,68.0,201.0};  //storage for adjustment of actual angles of wheel from motor controller encoder feedback
//float ZeroDir[4]={-73.0,116.0,156.0,208.0};  //storage for adjustment of actual angles of wheel from motor controller encoder feedback
//float ZeroDir[4]={113,36,79,-98} //3/18 3:35 pm;
//float ZeroDir[4]={113,36,79,-98}; //
//float ZeroDir[4]={-2,39,0,199};
//float ZeroDir[4]={5,56,-20,185}; 
//float ZeroDir[4]={14,90,-3,158}; //3/19  1:03 pm
//float ZeroDir[4]={31,107,14,175};  //3/19  4:39 pm //updated phoenix libs at 5
//float ZeroDir[4]={0,130,0,119}; //3/19 6:57 pm //tesing to see if encoders are reading correctly 
//float ZeroDir[4]={25,161,19,110}; //FL was -25 before 7:45, changed because we messed up a belt 
//float ZeroDir[4]={93,-75,-163,-22}; //reset to test if knee nibler code works instead //10 pm
//float ZeroDir[4]={110,169,-158,166}; // changed FR from 138 at 10:50 pm 3/19 // changed RL from 180 11:04
//float ZeroDir[4]={-75,90,0,0}; //3/20 12:13 pm //please fix last 2 wheels later
//float ZeroDir[4]={68,-56,0,-109}; //added at 7:51 pm after fixing issue
//float ZeroDir[4]={68,82,90,-62};
float ZeroDir[4]={144,141,163,298};
#endif
float TargetDir[4]={0.0,0.0,0.0,0.0};     //target degrees of each wheel
float ModDir[4]={0.0,0.0,0.0,0.0};        //rotational modification degrees of each wheel to adjust target
float ModSpd[4]={0.0,0.0,0.0,0.0};        //speed modification degrees of each wheel to adjust target
double SWRVY;							  //Swerve Control Variable--Represents Y coordinate of drive joystick
double SWRVX;                             //Swerve Control Variable--Represents X coordinate of drive joystick
double SWRVZ;                             //Swerve Control Variable--Represents X coordinate of rotate joystick
float delta =0.0;                         //local variable for determining best way(least delta degrees) to meet rotatioanl target
AHRS *ahrs;  //gyro
int TestNum=250;
double PercentData = 0;
int TargetIndex=0;
float ShootSpeedError=0.0;
float ShootHoodError=0.0;
double StartYPosition=0.0,StartXPosition=0.0;

#define NUM_DATA_CELLS 9
const double ShooterTable[3][NUM_DATA_CELLS]{
    {94, 111,133,157,178,203,240,264,285,},//Distance
    {30, 31, 32, 40, 40, 42, 61, 55, 68},  //hood angle 
    {166,166,171,196,200,203,221,229,212}  //Velocity
};



//Color Sernsor
#define REDBALL 0
#define BLUEBALL 1
#define NOBALL 2
static constexpr auto i2cPort = frc::I2C::Port::kOnboard;
rev::ColorSensorV3 m_colorSensor{i2cPort};
rev::ColorMatch m_colorMatcher;
  static constexpr frc::Color kBlueTarget = frc::Color(0.143, 0.427, 0.429);
  static constexpr frc::Color kRedTarget = frc::Color(0.561, 0.232, 0.114);
#define EJECT_TIME .5_s 
int  BallEject = 0;
#define BALL_PROXIMITY_MAX 2000
int Alliance;


#define Climb_Hold  0
#define Climb_Raise 1
#define Climb_Up    2
#define Climb_Arm   3
#define Climb_Drop  4
#define Climb_End   5
#define Climb_Reset 6



int ClimbState = Climb_Hold;
int ElevatorState = 0; //Raise=1,Lower=-1,Stop=0
int GearboxLocked = 0;
int launchArm = 0;
int isClimbing = 0;
double ElevatorLocation;
int ElevatorZero;
double ElevatorSpeed = 0;


#define ArmTime   .25_s
#define DROP_TIME .1_s
#define DROP_POS  10000 
#define Elevator_Top 32000 //not being used anymore
#define EL1     32 
#define EL2     31
#define EL3     30


//Autonomous field positions
int StartingLocation = 0;

#define NUMAUTOLINES 30

#define START 10
#define STOP  11
#define MOVE  12
#define FIRE  13
#define AUTO_WAIT_TIME 1_s
//Auto Pilot variables
    float TargetAngle;
	float CurrentAngle;
	float RotPwr;
	int    AutoLine=0,FirstPass=0,AutoFire=0;
	double RobotX[4]={0.0,0.0,0.0,0.0},RobotY[4]={0.0,0.0,0.0,0.0};
	double AutoDriveX, AutoDriveY, AutoDriveZ;

int *AutoArray;
// 2 Ball Auto
#define BNPW 20
int	TwoBall_AutoArray[NUMAUTOLINES][8]={ //` Test again!!!!
	        //CMD,   Acc mSec,Dec Inches, MaxPwr,TargetX, TargetY, Orientation Deg,IntakeState
			{START,      0,         0,      0,      0,      0,        0,            0},	//Start at midfield location
			{MOVE,    500,          5,   BNPW,     0,     43,        0,            1},	//Move back to ball on field
			{FIRE,       0,        0,        0,     0,      0,        0,            1},	//pin 1
          //  {FIRE,       0,        0,        0,     0,      0,        0,            1},	//pin 1
			{STOP,       0,         0,      0,       0,      0,        0,           0},	//STOP
};

int FiveBall_AutoArray[NUMAUTOLINES][8]={
            //CMD,   Acc mSec,Dec Inches, MaxPwr,TargetX, TargetY, Orientation Deg,IntakeState
			{START,      0,         0,      0,      0,      0,        0,            0},	//Start at midfield location
			{MOVE,    500,          5,   BNPW,     0,     -43,        0,            1},	//Move back to ball on field
			{FIRE,       0,        0,        0,     0,      0,        0,            1},	//pin 1
            {FIRE,       0,        0,        0,     0,      0,        0,            1},	//pin 1
            {MOVE,    500,         5,    BNPW,      -108,   12,       120,          1}, //go to third ball
            {FIRE,       0,        0,        0,     0,      0,        45,           1},
            {MOVE,    500,         5,    BNPW,      -250,  -43,        60,          1}, //grab ball by human player
            {MOVE,    500,         5,    BNPW,      -150,  -43,        60,          1}, //back away from wall
            {MOVE,    500,         5,      25,      -250,  -43,        60,          1}, //grab ball from human player
            {MOVE,    500,         5,    BNPW,      -100,  -43,        45,          1}, //back away from wall
            {FIRE,       0,        0,        0,     0,      0,        45,           1}, //fire ball
            {FIRE,       0,        0,        0,     0,      0,        45,           1}, //fire ball
            {STOP,       0,         0,      0,       0,      0,        0,           0},	//STOP

};

double outTargetInches,outInchesTraveled;

//Allows for Pid tuning using sliders
#ifdef PIDTUNE
    double PVALUE = frc::SmartDashboard::GetNumber("DB/Slider 0",-1);
    double IVALUE = frc::SmartDashboard::GetNumber("DB/Slider 1",-1);
    double DVALUE = frc::SmartDashboard::GetNumber("DB/Slider 2",-1);
#else
    const double PVALUE = 1.2; //1.2
    const double IVALUE = 0.00; //0.00 //0.003
    const double DVALUE = 0.00; //0
#endif

class Robot : public frc::TimedRobot
{
public:
    void RobotInit(void);
//AUTONOMOUS DRIVING STATE MACHINE
    void AutoStateMachine(void){
		int *Array;
        double InchesTraveled,TargetInches;
		int MaxFromDcel,MaxFromAcel;
		double MaxPower,X,Y,Z ,DeltaA,fctr;
	    int Command, AccSec, DecInches, Speed, AutoX, AutoY, Orientation, IntakeDIR;
        //point data to current autonomous command line
	    Array=AutoArray+(AutoLine*8); 
		Command=*Array;
		Orientation=*(Array+6);
		Speed=*(Array+3);
		AccSec=*(Array+1);
		DecInches=*(Array+2);
        AutoX=*(Array+4);
		AutoY=*(Array+5);
		IntakeDIR=*(Array+7);
        if(FirstPass){
           StartXPosition=RobotX[IDX];
           StartYPosition=RobotY[IDX];

        }
        
		//distance to target
		InchesTraveled=(int)sqrt(pow((double)(RobotX[IDX]-StartXPosition),2)+pow((double)(RobotY[IDX]-StartYPosition),2));
        TargetInches=(int)sqrt(pow((double)(AutoX-StartXPosition),2)+pow((double)(AutoY-StartYPosition),2));
		//Max speed percentage based on deceleration value given 
		MaxFromDcel=(pow(TargetInches-InchesTraveled,2)*10000)/pow(DecInches,2);
		//Get msec since we started and divide by msec to full power for power limit from acceleration
		//MaxFromAcel=(int)(AutoTimer.Get()*100000)/AccSec;
        MaxFromAcel=100;

		//MaxFromAcel=100;
		//MaxFromDcel=100;

        if(MaxFromDcel<MaxFromAcel){
			MaxPower=(MaxFromDcel*Speed)/100;
        }else{
			MaxPower=(MaxFromAcel*Speed)/100;
		}
		if(MaxPower>Speed)MaxPower=Speed;
		if(MaxPower<0)MaxPower=0;
		//Calculate the X,Y direction to target
		X=(AutoX-(int)RobotX[IDX]);
		Y=(AutoY-(int)RobotY[IDX]);
		//Calculate the delta in the robot orientation target
		DeltaA=(RobotAngle-Orientation);
		Z=(DeltaA*-1.0)/90.0;
		if(Z>1.0)Z=1.0;
		if(Z<-1.0) Z=-1.0;

		if(AutoLine>NUMAUTOLINES) Command=STOP; //in case no one put in a stop command
		if(IntakeDIR>0){
			Intake_On=1;
            
		} 

		switch(Command){ //command mode
		    case START: 
			            RobotX[IDX]=(double)AutoX;
						RobotY[IDX]=(double)AutoY;
						ResetGyro();
						AutoLine++;
						FirstPass=1;
					    break;
			case MOVE:  //Determine direction and rotation values from autonomous command
			            fctr=fabs(X)+fabs(Y);
						if(fctr==0.0) fctr=1.0;
						
						
						AutoDriveX=(double)((X/(fctr))*MaxPower)/100.0;
						AutoDriveY=(double)((Y/(fctr))*MaxPower)/100.0;
		               
					    AutoDriveZ=Z; //(double)(pow(Z,3)/15);
					
						if((TargetInches-InchesTraveled)<(Speed/5.0)){
                           AutoLine++;
                           AutoDriveX=0;
                           AutoDriveY=0;
                           AutoDriveZ=0;
						   AutoTimer.Reset();
						   FirstPass=1;
						}else FirstPass=0;


						break;
            case FIRE:  //Determine direction and rotation values from autonomous command
			           if(FirstPass){
                           AutoTargeting=1;
                           AutoFire=1;
                       } 
                       FirstPass=0;
                       if(!AutoFire){ //Ball Shot?
                           AutoLine++;
						   AutoTimer.Reset();
						   FirstPass=1;
                       }
                        break;

			default:
			case STOP:
						AutoDriveX=0.0;
						AutoDriveY=0.0;
						AutoDriveZ=0.0;
						FirstPass=0;
						break;
			
		}

		outInchesTraveled = InchesTraveled;
        outTargetInches=TargetInches;
	

    }
int ShooterStable(){

      //Shooter Velocity is a negatve number, Target is posative
     if(Shooter_Speed_Target>1) ShootSpeedError=100*(fabs(Shooter_Speed_Target-ShooterVelocity)/Shooter_Speed_Target);
     else ShootSpeedError=100;

     ShootHoodError=(fabs((float)HoodTarget-(float)HoodLocation)/HoodTarget);

    

      if(ShootSpeedError>15 || ShootHoodError>15 /*`|| fabs(targetOffsetAngleHorizontal/15.0)>.5*/) return(0); //was 10, but 10 is too low
      else return(1);
  }  

  void SetShooterVals(){
        
        
        //could add binary search, but it isn't really worth the effort
        if(BallEject){
            CalcHoodTarget= 10;
            Shooter_Speed_Target = 50;
        }else {
            for(int i=1;i<NUM_DATA_CELLS;i++){
                if(ShooterTable[0][i] > DistanceToGoal || i+1==NUM_DATA_CELLS){
                    PercentData = (DistanceToGoal - ShooterTable[0][i-1]) / (ShooterTable[0][i] - ShooterTable[0][i-1]);
                    //Sets Angle and Velocity
                    CalcHoodTarget=((ShooterTable[1][i]-ShooterTable[1][i-1]) * PercentData) + ShooterTable[1][i-1];
                    Shooter_Speed_Target = ((ShooterTable[2][i]-ShooterTable[2][i-1]) * PercentData) + ShooterTable[2][i-1];
                
                    TargetIndex=i;
                
                    break;
                }
            }
        }

        //Shooter_Speed_Target=220; //!!!Temporary
    }

	void SetHood(int percent){ // In percent 0-100
        #ifdef CALHOOD
            Hood_Motor.Set(ControlMode::PercentOutput,Arm_Stick.GetY());
        #else
        //#define HOOD_MAX -5270
        #define HOOD_MIN (HoodMax-1200)     //get acurate values through testing 

        hoodPercent = percent;
        if(HoodInitialized==1){
            HoodResetTimer.Reset();
            HoodResetTimer.Start();
            HoodInitialized=2;
        }
        if(HoodResetTimer.Get()>2_s){
           
            if(HoodMax==0){
                  HoodInitialized=3;
                  HoodResetTimer.Stop();
                  HoodMax=Hood_Motor.GetSelectedSensorPosition()+1;
                  Hood_Motor.Set(ControlMode::PercentOutput,0);
            }    
         
            HoodTarget=(((100-percent)*((HoodMax-HOOD_MIN))+50)/100) + HOOD_MIN; 
           
            if(percent>=HoodMax) percent = HoodMax;
            if(percent<=HOOD_MIN) percent = HOOD_MIN;
        
            Hood_Motor.Set(ControlMode::Position,HoodTarget);
       
            HoodLocation=(int)Hood_Motor.GetSelectedSensorPosition();
        }
       #endif
    }

    void TargetLime(void)
    {
              
            //Get offset values from Limelight
            targetOffsetAngleHorizontal = table->GetNumber("tx",0.0);
            targetOffsetAngleVertical = table->GetNumber("ty",0.0);
            targetArea = table->GetNumber("ta",0.0); //area
                 
            if (targetArea>0){  //Shooter in autotarget and target in view
                DistanceToGoal = (TARGET_ABOVE_CAMERA / tan((CAMERA_ANGLE + targetOffsetAngleVertical) * PI / 180.0)) + ADD_TO_INNER_GOAL;
            } else{
                DistanceToGoal = -100000;
            }
            

        
    }

    void Climber()
    {
        ElevatorLocation = Elevator_1.GetSelectedSensorPosition();// - ElevatorZero);
        
        
        if(Arm_Stick.GetRawButton(7)) {
            //ClimbState = Climb_End;
            GearboxLocked=1;
            ElevatorSpeed=0;
            isClimbing=0;
        }
        //`if(Arm_Stick.GetRawButton(9) && (Dir_Stick.GetRawButton(11) || isClimbing)) launchArm = 1;
        //`else launchArm=0;

        /* Removed because unnecessary
            switch(ClimbState){
            default:
                ClimbState = Climb_Hold;
                break;
            case Climb_Hold:
                ElevatorState=0;
                GearboxLocked=1;
                if(isClimbing){
                    ClimbState = Climb_Raise;
                    ClimbTimer.Reset();
                }
                break;

            case Climb_Raise:
                ElevatorState=Elevator_Top;
                GearboxLocked=0;
                if(ElevatorLocation>=(int)(Elevator_Top*.9) && Arm_Stick.GetRawButton(10)){
                    ClimbState = Climb_Up;
                    ClimbTimer.Reset();
                }
                break;
            case Climb_Up:
                ElevatorState=0;
                GearboxLocked=0;
                if(ElevatorBottom.Get() || ElevatorLocation<=1 || ClimbTimer.Get()>2_s){ 
                    ClimbState = Climb_Arm;
                    ClimbTimer.Reset();
                }
                break;
            case Climb_Arm:
                ElevatorState=0;
                GearboxLocked=1;
                if(launchArm){
                    ClimbState = Climb_Drop;
                    ClimbTimer.Reset();
                }
                break;
            case Climb_Drop:
                GearboxLocked=0;
                if(Arm_Stick.GetRawButton(10)) ElevatorState=DROP_POS;
                if(ElevatorLocation>(int)(DROP_POS*1.1)){
                        ClimbState = Climb_End;
                        ClimbTimer.Reset();
                }
                break;
            case Climb_End:
                GearboxLocked=1;
                isClimbing = 0;
                break;
        }
        //}else{

        //}

        if(Arm_Stick.GetRawButton(11)){
            ElevatorSpeed=-Arm_Stick.GetY();
            GearboxLocked=0;
        }else{
            ElevatorSpeed = (ElevatorState - ElevatorLocation) / 40000.0;
        }
        */

        if(Arm_Stick.GetRawButton(11)){
            isClimbing=1;
            ElevatorSpeed=Arm_Stick.GetY(); 
            GearboxLocked=0;
        }else{
           ElevatorSpeed=0; // ElevatorSpeed = (ElevatorState - ElevatorLocation) / 40000.0;
           GearboxLocked=1;
        }

        Gearbox_Lock.Set(!GearboxLocked);
        //`Telescope_Lock.Set(launchArm); 
    
        
        if(ElevatorSpeed>1) ElevatorSpeed = 1; //change to max speed for not tension //moved from 1.0
        if(ElevatorSpeed<-1) ElevatorSpeed = -1; //change to max speed with tension
        //if(fabs(ElevatorSpeed)<0.1)
        if(GearboxLocked) ElevatorSpeed=0;
        Elevator_1.Set(ControlMode::PercentOutput,-0.8*ElevatorSpeed);
        Elevator_2.Set(ControlMode::PercentOutput,-0.8*ElevatorSpeed);
        Elevator_3.Set(ControlMode::PercentOutput,-0.8*ElevatorSpeed);
        
    

    }

    void Intake()
    {
        if(IsAutonomousEnabled()){
            IntakeIsDown=1;
            Intake_On=1;
            Magazine_On=1;
        }else{

        
            if (Dir_Stick.GetRawButton(3)) //Intake Up
            {
                IntakeIsDown = 0;
                Intake_Cylinder.Set(0);
                Intake_On=-1;
            }
            else if (Dir_Stick.GetTrigger())//Make Intake Down
            {
                IntakeIsDown = 1;
                Intake_Cylinder.Set(1);
            }
            //Intake balls if not shooting
            if(!Shooter_On){
                if (Dir_Stick.GetTrigger())
                {
                    Intake_On=1; 
                    Magazine_On=1;
                }
                else if (Dir_Stick.GetRawButton(2))
                {
                    Intake_On=-1; 
                    Magazine_On = -1;
                }
                else
                {
                    Intake_On=0; 
                    Magazine_On = 0;
                }
            }
        }
    
        if(!IntakeIsDown){
            Intake_Cylinder.Set(0);
        }
        else {
            Intake_Cylinder.Set(1);
        }

        if(Intake_On==1){
           Intake_Motor.Set(ControlMode::PercentOutput, .8);//forward
        }else if(Intake_On==-1){
            Intake_Motor.Set(ControlMode::PercentOutput, -.8);//reverse
        }else{
            Intake_Motor.Set(ControlMode::PercentOutput, 0);//off
        }


        if(Magazine_On==1&&(GetBallColor()<NOBALL)&&!TriggerRunning){
           Magazine_On=0;
        }
        if (Magazine_On == 1) {
            Magazine_Motor.Set(ControlMode::PercentOutput, 1); //forward
        }else if (Magazine_On == -1) {
            Magazine_Motor.Set(ControlMode::PercentOutput, -1.0);//reverse
        } else{
            Magazine_Motor.Set(ControlMode::PercentOutput, 0); //off
        }

        
    }

    int GetBallColor(){

        double confidence = 0.0;

        frc::Color matchedColor = m_colorMatcher.MatchClosestColor(m_colorSensor.GetColor(), confidence);

        if(m_colorSensor.GetProximity() < BALL_PROXIMITY_MAX){
            return NOBALL;
        }
        if(matchedColor == kBlueTarget){

            return BLUEBALL;

        }else if(matchedColor == kRedTarget){

           return REDBALL;

        }else{

            return NOBALL;

        }

        

    }


#define TRIGGER_TIME .25_s //1_s
    void Shooter()
    {

        //if(GetBallColor() == Alliance) BallEject=0;
        //if(GetBallColor() == !Alliance) BallEject=1;

        if(Arm_Stick.GetRawButton(3)){//manual targeting
            AutoTargeting=0;
            SetHood((int)((Arm_Stick.GetZ()+1.0)*50.0));
            Shooter_On=1;
            Magazine_On=1;
            if(Arm_Stick.GetTrigger()){
                Intake_On=1;
                Shooter_Trigger_On=1;
               
            }else{
                Shooter_Trigger_On=0;
            }
            
        }else{ //Automatic Mode

            switch (AutoShootState){
                default:
                        AutoShootState=STATE_HOLD;
                        break;
                case STATE_HOLD:
                       
                        if(!AutoTargeting){
                            AutoTargeting=1;
                            AutoShootState=STATE_END;
                        }else if((Arm_Stick.GetTrigger() && !Arm_Stick.GetRawButton(3)) || AutoFire){
                             AutoShootState=STATE_FILL_MAGAZINE;
                            SpinUpTimer.Reset();
                            SpinUpTimer.Start();
                        }
                        
                        if(HoodInitialized==3)SetHood(10); 
                        else SetHood(0);
                         break;
                case STATE_FILL_MAGAZINE:
                        if(!Arm_Stick.GetTrigger()&&!IsAutonomousEnabled()) AutoShootState=STATE_END;
                        
                        if(!(GetBallColor()<NOBALL)) Magazine_On=1;
                        else Magazine_On=0;
                       
                        Shooter_On=1;
                        Intake_On=1;
                        //if(GetBallColor()== !Alliance && (GetBallColor()<NOBALL)){
                        //    AutoShootState = STATE_EJECT;
                        //}else
                        if(((GetBallColor()<NOBALL) && ShooterStable()) ||  SpinUpTimer.Get()>1_s){ //was 4_s//@Maybe just use spinuptimer to give it time to reach speed
                            AutoShootState=STATE_TRIGGER;
                        }
                         break;
                case STATE_TRIGGER:
                        Magazine_On=1;
                        Shooter_On=1;
                        Intake_On=1;
                        Shooter_Trigger_On=1;
                        if(!Arm_Stick.GetTrigger()&&!IsAutonomousEnabled()) {
                            AutoShootState=STATE_END;                          
                        }else if(TriggerTimer.Get() > TRIGGER_TIME){ 
                            Magazine_On=0;
                            Shooter_On=0;
                            Intake_On=0;
                            //Shooter_Trigger_On=0;
                            AutoShootState=STATE_FILL_MAGAZINE;
                            SpinUpTimer.Reset();
                            SpinUpTimer.Start();
                        }
                        
                        break;
                 /*case STATE_EJECT:
                        Magazine_On=1;
                        Shooter_On=1;
                        Intake_On=1;
                        Shooter_Trigger_On=1;
                        Shooter_Speed_Target = 50;
                        SetHood(10);
                        if(!Arm_Stick.GetTrigger()&&!IsAutonomousEnabled()) {
                            AutoShootState=STATE_END;                          
                        }else if(TriggerTimer.Get() > TRIGGER_TIME){ 
                            Magazine_On=0;
                            Shooter_On=0;
                            Intake_On=0;
                            //Shooter_Trigger_On=0;
                            AutoShootState=STATE_FILL_MAGAZINE;
                            SpinUpTimer.Reset();
                            SpinUpTimer.Start();
                        }
                    */
                 case STATE_END:
                        Magazine_On=0;
                        Shooter_On=0;
                        Intake_On=0;
                        Shooter_Trigger_On=0;
                        AutoShootState=STATE_HOLD;
                        AutoFire=0;
                        break;

            }
          
            if(DistanceToGoal>ShooterTable[0][0]&&AutoShootState!=STATE_HOLD){
                SetShooterVals(); //makes sure that the limelight sees the target
                //!!!Add code to auto rotate swerves
                SetHood(hoodPercent);

            } 
        }
        TriggerRunning=0;

        //if(Rot_Stick.GetRawButton(9)){
        //    Shooter_Trigger_On=1;
        //}
       
        #ifndef NOBALLEJECT 
            if(GetBallColor() == !Alliance && Arm_Stick.GetTrigger()){
                Shooter_On=1;
                Shooter_Trigger_On=1;
                SetHood(10);
            }else if(EjectTimer.Get()>TRIGGER_TIME){
                Shooter_On=0;
                Shooter_Trigger_On=0;
                EjectTimer.Reset();
                EjectTimer.Stop();
            }

        #endif
        

        if(Shooter_Trigger_On){
                if(TriggerTimer.Get()>TRIGGER_TIME && !Rot_Stick.GetRawButton(9)){
                    Trigger_Motor.Set(ControlMode::PercentOutput, 0); //off
                }else{
                    TriggerRunning=1;
                    Trigger_Motor.Set(ControlMode::PercentOutput,-1); //trigger running //-0.8
                }        
         }else{
             TriggerTimer.Reset();
             Trigger_Motor.Set(ControlMode::PercentOutput, 0); //off
         } 

        if(Shooter_On){
            if(!AutoTargeting){
                  if(BallEject) Shooter_Speed_Target=50;
                  else Shooter_Speed_Target=((int)((Dir_Stick.GetZ()+1.0)*64.0+64.0));
            } 
        }else{
            #ifdef STOPSHOOTERSPIN
                Shooter_Speed_Target=0;
            #else
           if(isClimbing){ 
               Shooter_Speed_Target=0;
               SetHood(0);
           }else{
               Shooter_Speed_Target=50;
           }
           #endif
        }

        if(Arm_Stick.GetRawButton(12)){
            Shooter_Speed_Target=50;
            Shooter_On=1;
            Shooter_Trigger_On=1;
            SetHood(10);
            EjectTimer.Reset();
            EjectTimer.Start();
        }
         
        
        
        
       

        Shooter_Motor.Set(ControlMode::Velocity,Shooter_Speed_Target); //0 to 1024 //inverted from -
        ShooterVelocity=Shooter_Motor.GetSelectedSensorVelocity(1)/64;
      
        
    }

    int gUpdateCount = 0; ///counter to be sure we only update drive screen every once in a while so it does not bog down the network
    void UpdateDriverScreen(void) //` fix later to display what you actually want
    {
        char str[40];
        int light;

        if (gUpdateCount <= 0)
        {
            gUpdateCount = 25; //delay between displays to not bog down system
            sprintf(str, "H:%d,T%d,A%d,P%d", HoodInitialized,HoodTarget,HoodLocation,hoodPercent);
            frc::SmartDashboard::PutString("DB/String 0", str);

            sprintf(str, "PD:%4.2f I:%d",PercentData,TargetIndex);
            sprintf(str,"BC%d",GetBallColor());
			//frc::SmartDashboard::PutString("DB/String 7", str);
            sprintf(str, "Ang%3.0f,Err%3.0f",RobotAngle);
			frc::SmartDashboard::PutString("DB/String 6", str);
            sprintf(str, "S:T%5.0f,A%5.0f",Shooter_Speed_Target,ShooterVelocity);
        
			sprintf(str, "TY %4.2f Area %4.2f",targetOffsetAngleVertical, targetArea);
			frc::SmartDashboard::PutString("DB/String 8", str);
			//sprintf(str, "TX %4.2f Dst %4.2f", targetOffsetAngleHorizontal);
			//frc::SmartDashboard::PutString("DB/String 9", str);
            sprintf(str, "BD %d, St:%d",GetBallColor(), AutoShootState);
            frc::SmartDashboard::PutString("DB/String 9",str);



           //Code for displaying swerve values
           #ifdef DISP_ENCODER_VALS
           sprintf(str,"FLA%4.2f,T:%4.2f",(FLSteer.GetSensorCollection().GetPulseWidthPosition() / (ENCODER_RES_FL/360.0))+ZeroDir[FL],TargetDir[FL]-ZeroDir[FL]);
           frc::SmartDashboard::PutString("DB/String 0",str);
           sprintf(str,"FRA%4.2f,T:%4.2f",(FRSteer.GetSensorCollection().GetPulseWidthPosition()/(ENCODER_RES_FR/360.0))+ZeroDir[FR],TargetDir[FR]-ZeroDir[FR]);
           frc::SmartDashboard::PutString("DB/String 1",str);
           sprintf(str,"RLA%4.2f,T:%4.2f",(RLSteer.GetSensorCollection().GetPulseWidthPosition()/(ENCODER_RES_RL/360.0))+ZeroDir[RL],TargetDir[RL]-ZeroDir[RL]);
           frc::SmartDashboard::PutString("DB/String 2",str);
           sprintf(str,"RRA%4.2f,T:%4.2f",(RRSteer.GetSensorCollection().GetPulseWidthPosition()/(ENCODER_RES_RR/360.0))+ZeroDir[RR],TargetDir[RR]-ZeroDir[RR]);
           frc::SmartDashboard::PutString("DB/String 3",str);

            #endif

           
            
            //if(isClimbing){
                sprintf(str,"ES:%4.4fTL:%d,GL%d",ElevatorSpeed,Telescope_Lock.Get(),Gearbox_Lock.Get());
                //frc::SmartDashboard::PutString("DB/String 6",str);
            //}

            #ifdef CALSWERVE
                //sprintf(str,"ZeroDir: %4.2f",ZeroDir[FR]);
                //frc::SmartDashboard::PutString("DB/String 4",str);
            #endif

            sprintf(str,"BD:%d,SS%d,PG%4.2f",GetBallColor(),ShooterStable(),fabs(targetOffsetAngleHorizontal/15.0));
            frc::SmartDashboard::PutString("DB/String 5",str);
            sprintf(str,"HE:%4.2f,SE:%4.2f",ShootHoodError,ShootSpeedError);
            frc::SmartDashboard::PutString("DB/String 6",str);

            light = (GetBallColor()<NOBALL);
            frc::SmartDashboard::PutNumber("DB/LED 0",light);
            light = ElevatorBottom.Get();
            frc::SmartDashboard::PutNumber("DB/LED 1",light);


        }
        gUpdateCount--;
    } // End UpdateDriverScreen
 //This is were the SWRVX,SWRVY,SWRVZ values are set to direct the swerve drives where to go
	void SwerveControl(void){
		//AutoPilot?
	    if(IsAutonomousEnabled()){
			FieldCentric=1; //Auto operates in field centric mode
		    SWRVY=AutoDriveY;
			SWRVX=AutoDriveX; 
		    
            if(targetArea>0&&AutoTargeting&&AutoShootState!=STATE_HOLD){
                //if((targetOffsetAngleHorizontal/15.0) > 1.0) SWRVZ = 1.0;
                //else if((targetOffsetAngleHorizontal/15.0) < -1.0) SWRVZ = -1.0;
                //else if((targetOffsetAngleHorizontal/15.0) < .5) SWRVZ = .5;
                //else if((targetOffsetAngleHorizontal/15.0) > -.5) SWRVZ = -.5;
                //else SWRVZ = (targetOffsetAngleHorizontal/15.0);
                SWRVZ = (targetOffsetAngleHorizontal/15.0);
            }else{
                SWRVZ=AutoDriveZ;
            }
			if(SWRVZ>5.0)SWRVZ=5.0;
			if(SWRVZ<-5.0) SWRVZ=-5.0;
			if(SWRVY>1.0)SWRVY=1.0;
			if(SWRVY<-1.0) SWRVY=-1.0;
			if(SWRVX>1.0)SWRVX=1.0;
			if(SWRVX<-1.0) SWRVX=-1.0;
		}else{ //Teleop Mode
			SWRVY=-Dir_Stick.GetY();
			if (fabs(SWRVY)<0.1) SWRVY=0.0;
			SWRVX=Dir_Stick.GetX();
			if (fabs(SWRVX)<0.1) SWRVX=0.0;
			SWRVZ=Rot_Stick.GetX();
            if((SWRVZ<0.1 && SWRVZ>0.1) || (SWRVZ>-0.1 && SWRVZ<0.1)) SWRVZ=0.0;
            if(!AutoTargeting){
                SWRVZ=Arm_Stick.GetX();
            }
            if(targetArea>0&&AutoTargeting&&AutoShootState!=STATE_HOLD){
                SWRVZ = (targetOffsetAngleHorizontal/15.0); //`fix this
            }
			if(Rot_Stick.GetTrigger()) FieldCentric=0;
			else FieldCentric=1;	  
		}
		//Button 6 on left joystick resets the gyro to 0 degrees
		if(Dir_Stick.GetRawButton(6))
		{
			ResetGyro();
		}
	
  }	// End SwerveControl

  //Do the math on each wheel to find the new angle and speed required
  void  Calc4WheelTurn(){

	  double A,B,C,D,R,temp;
	  int i;
	  R=sqrt(pow(SW_L,2))+(pow(SW_W,2));

	  A=SWRVX-SWRVZ*(SW_L/R);
	  B=SWRVX+SWRVZ*(SW_L/R);
	  C=SWRVY-SWRVZ*(SW_W/R);
	  D=SWRVY+SWRVZ*(SW_W/R);

	  ModDir[FR] = atan2(B,C)*180/PI;
	  ModSpd[FR]=  sqrt(pow(B,2)+pow(C,2));

	  ModDir[FL] = atan2(B,D)*180/PI;
	  ModSpd[FL]=  sqrt(pow(B,2)+pow(D,2));

	  ModDir[RL] = atan2(A,D)*180/PI;
	  ModSpd[RL]=  sqrt(pow(A,2)+pow(D,2));

	  ModDir[RR] = atan2(A,C)*180/PI;
	  ModSpd[RR]=  sqrt(pow(A,2)+pow(C,2));

	  temp=0;
	  for(i=0;i<4;i++){
		  if(ModSpd[i]>temp) temp=ModSpd[i];
	  }
	  if(temp>1.0){
		  for(i=0;i<4;i++) ModSpd[i]/=temp;
	  }
 	 return;
  }

  //Modify the Target direction given the new the direction from Calc4WheelTurn() using shortest distance calculations
  void SetDirection(int channel) {
		int curdir;
 
		if(SpeedPolarity[channel] < 0.0){
			curdir=fmod((TargetDir[channel]+180.0),360.0);
		} else {
			curdir=fmod(TargetDir[channel],360.0);
		}
		
		delta=ModDir[channel]-curdir+ZeroDir[channel]; //What is the distance to move?  How best to get there...

		//delta=fmod(delta,360.0);
		//Is Fastest way across 0 boundary?
		if(delta<-180.0) {  //Don't turn more than 180 degrees
			delta+=360.0;
		}
		if(delta>180.0) {
			delta-=360.0;
		}
		if(delta<=90.0 && delta>=-90.0) { //direct move without direction change
			TargetDir[channel]+=delta;
		} else {
			if(delta>90.0) delta-=180.0;
			if(delta<-90.0) delta+=180.0;
			TargetDir[channel]-=delta;
			if(SpeedPolarity[channel]>0.0 ) SpeedPolarity[channel]=-1.0; //switch directions so we steer less
			else SpeedPolarity[channel]=1.0;
		}
	}	// End SetDirection

	float CVTSpeed(float speed) {
			if(speed>1.0) speed=1.0;
			if(speed<-1.0) speed=-1.0;
			return(-speed);
    }	// End CVTSpeed

	//controlling the direction and speed of the swerve drives
    
    void SwerveDrive(void) {
    	int i;
    	float Gyro,temp;
      
    	//Read encoder counts and then divide to get degrees of rotation
    	ActDir[FL]=fmod((FLSteer.GetSensorCollection().GetPulseWidthPosition()/(ENCODER_RES_FL/360.0)) - ZeroDir[FL],360.0); //was divided by 11.38
		ActDir[FR]=fmod((FRSteer.GetSensorCollection().GetPulseWidthPosition()/(ENCODER_RES_FR/360.0)) - ZeroDir[FR],360.0);
    	ActDir[RL]=fmod((RLSteer.GetSensorCollection().GetPulseWidthPosition()/(ENCODER_RES_RL/360.0)) - ZeroDir[RL],360.0);
    	ActDir[RR]=fmod((RRSteer.GetSensorCollection().GetPulseWidthPosition()/(ENCODER_RES_RR/360.0)) - ZeroDir[RR],360.0);
      // ActDir[FL]=FLSteer.GetSelectedSensorPosition()/(ENCODER_RES/360.0);
       //ActDir[FR]=FRSteer.GetSelectedSensorPosition()/(ENCODER_RES/360.0);
       //ActDir[RL]=RLSteer.GetSelectedSensorPosition()/(ENCODER_RES/360.0);
       //ActDir[RR]=RRSteer.GetSelectedSensorPosition()/(ENCODER_RES/360.0);

		//If rotational power is low, just don't rotate
        if(IsAutonomousEnabled()){
               //SWRVZ=pow(3*SWRVZ,3);
		}else{

			if (fabs(SWRVZ)<0.1){
				SWRVZ=0.0;
			}else{
				//if(Rot_Stick.GetRawButton(8)) { // button 8 for fast rotation
					SWRVZ=pow(2.5*SWRVZ,3);  // show off (or big, heavy frame)
				//} else {
				//	SWRVZ=pow(1*SWRVZ,3); // small frame normal rotation
				//}
			}
	    }
		//deermine if we are field or robot centric and make the adjustment here if necessary    
	    if(FieldCentric||IsAutonomousEnabled()) Gyro=RobotAngle*PI/180;
	    else Gyro=0;

		//modify the target robot direction from field centric to robot centric for wheel positions and then set them in calc4wheel
	    temp=SWRVY*cos(Gyro)+SWRVX*sin(Gyro);
	    SWRVX=-SWRVY*sin(Gyro)+SWRVX*cos(Gyro);
	    SWRVY=temp;
		Calc4WheelTurn();

		for(i=0;i<4;i++) SetDirection(i);

        
        //send the drive motor speeds to the motor controllers
		FLDrive.Set(ControlMode::PercentOutput,CVTSpeed(SpeedPolarity[FL]*ModSpd[FL]));
		FRDrive.Set(ControlMode::PercentOutput,CVTSpeed(SpeedPolarity[FR]*ModSpd[FR]));
		RLDrive.Set(ControlMode::PercentOutput,CVTSpeed(SpeedPolarity[RL]*ModSpd[RL]));
		RRDrive.Set(ControlMode::PercentOutput,CVTSpeed(SpeedPolarity[RR]*ModSpd[RR]));

		//Steer.Set(ControlMode::Position,fabs(Dir_Stick.GetX())*8000.0); //(TargetDir[FL]/360.0)*ENCODER_RES);
	    //FRSteer.Set(ControlMode::Position,fabs(Dir_Stick.GetX())*8000.0); //(TargetDir[FR]/360.0)*ENCODER_RES);
	   // RRSteer.Set(ControlMode::Position,fabs(Dir_Stick.GetX())*8000.0); //(TargetDir[RR]/360.0)*ENCODER_RES);
		//RLSteer.Set(ControlMode::Position, fabs(Dir_Stick.GetX())*8000.0); //(TargetDir[RL]/360.0)*ENCODER_RES);
        #ifdef ENCODER_VALS
        if(!Dir_Stick.GetRawButton(8)&&!Dir_Stick.GetRawButton(9)) nokey=1;
        
        if(nokey==1){
            
           if(Dir_Stick.GetRawButton(8)){
               TestF+=3600.0; //45.0;
               nokey=0;
           }
           if(Dir_Stick.GetRawButton(9)){
               TestF-= 3600.0;//45.0;
               nokey=0;
           }
        }
        

        TargetDir[FL]=TestF;
        #endif

        if(Rot_Stick.GetRawButton(8)){
            TargetDir[RR]=0;
            TargetDir[FR]=0;
            TargetDir[FL]=0;
            TargetDir[RL]=0;
        }

        FLSteer.Set(ControlMode::Position,(TargetDir[FL]/360.0)*ENCODER_RES_FL);
	    FRSteer.Set(ControlMode::Position,(TargetDir[FR]/360.0)*ENCODER_RES_FR);
	    RRSteer.Set(ControlMode::Position,(TargetDir[RR]/360.0)*ENCODER_RES_RR);
		RLSteer.Set(ControlMode::Position,(TargetDir[RL]/360.0)*ENCODER_RES_RL);
  
    }	// End SwerveDrive

double NewPosition[4],OldPosition[4];
	//Track robot FL wheel X,Y position in inches Y is long side of field X is width
    void TrackRobot(void){
		int i;
        double Dist,Dir;
		for(i=0;i<4;i++){
	     	//Determine distance moved since last time in this routine
			NewPosition[i]=GetLocation(i);
			Dist=NewPosition[i]-OldPosition[i];
			OldPosition[i]=NewPosition[i];
			Dir=ActDir[i]+RobotAngle;
			Dir=fmod(Dir,360.0);
			RobotX[i]+=Dist*sin((Dir*PI)/180.0);
			RobotY[i]+=Dist*cos((Dir*PI)/180.0);
		}
	}	// End TrackRobot

    double GetLocation(int i){
		double result;
		switch (i){ 
			case FL:
				result=FLDrive.GetSelectedSensorPosition();
				break;
			case FR:
				result=FRDrive.GetSelectedSensorPosition();
				break;
			case RL:
				result=RLDrive.GetSelectedSensorPosition();
				break;
			case RR:
				result=RRDrive.GetSelectedSensorPosition();
				break;
			default:
				result=0.0;
		}
		return(result/850); //772.5 //678.44);
	}

    void ReadGyro(void) {
		RobotAngle = ahrs->GetYaw();
	}	// End ReadyGyro
	void ResetGyro(void) {
		ahrs->ZeroYaw();
	}	// End ResetGyro

    void ConfigPID(void) {
        #ifdef PIDTUNE
        PVALUE = frc::SmartDashboard::GetNumber("DB/Slider 0",-1);
        IVALUE = frc::SmartDashboard::GetNumber("DB/Slider 1",-1);
        DVALUE = frc::SmartDashboard::GetNumber("DB/Slider 2",-1);
        #endif
        FRSteer.Config_kP(0, PVALUE, TIMEOUT);
		FRSteer.Config_kI(0, IVALUE, TIMEOUT);
		FRSteer.Config_kD(0, DVALUE, TIMEOUT);

        FLSteer.Config_kP(0, PVALUE, TIMEOUT);
		FLSteer.Config_kI(0, IVALUE, TIMEOUT);
		FLSteer.Config_kD(0, DVALUE, TIMEOUT);

        RRSteer.Config_kP(0, PVALUE, TIMEOUT);
		RRSteer.Config_kI(0, IVALUE, TIMEOUT);
		RRSteer.Config_kD(0, DVALUE, TIMEOUT);

        RLSteer.Config_kP(0, PVALUE, TIMEOUT);
		RLSteer.Config_kI(0, IVALUE, TIMEOUT);
		RLSteer.Config_kD(0, DVALUE, TIMEOUT);
    }

void AutonomousPeriodic() override
    {
        if (!Initialized)
        {
            RobotInit();
            Initialized=1;   
            switch(StartingLocation){
                //change which arrays are selected in the future
                default:
                case 0:  AutoArray = (int*)&TwoBall_AutoArray; break;
                case 1:  AutoArray = (int*)&TwoBall_AutoArray; break;
                case 2:  AutoArray = (int*)&TwoBall_AutoArray; break;
                case 3:  AutoArray = (int*)&TwoBall_AutoArray; break;
                case 4:  AutoArray = (int*)&TwoBall_AutoArray; break;
                case 5:  AutoArray = (int*)&TwoBall_AutoArray; break;
                break;
            }
            
   	
        }
   	
        	
		ReadGyro();              //get the angle of the robot in to variable "RobotAngle"
		TrackRobot();			//Track the Robot's FL wheel X,Y position around the field
		
        AutoStateMachine();      //Get updated directional commands from autopilot
		if(!FirstPass) {		// don't try to control anything when state changes
			SwerveControl();         //convert auto pilot commands to joystick motions
			SwerveDrive();           //Update the speed and direction of the swerve drive motors
		}
         TargetLime();
	     Intake();
         Shooter();
         UpdateDriverScreen();
          hoodPercent=CalcHoodTarget;
    }

    void TeleopPeriodic() override
    {

        if (!Initialized)
        {
            RobotInit(); //@begin code comment
            Initialized=1;
        }
       #ifdef CALSWERVE
       //if(Arm_Stick.GetRawButton(5)){
         //ZeroDir[FR]=Arm_Stick.GetX()*360.0;
         //ZeroDir[FL]=Arm_Stick.GetX()*360.0;
         //ZeroDir[RR]=Arm_Stick.GetX()*360.0;
         //ZeroDir[RL]=Arm_Stick.GetX()*360.0;
       //}
        ZeroDir[RR]=frc::SmartDashboard::GetNumber("DB/Slider 0",0)*72; //` add functionality to automatically rap around to negative numbers
        ZeroDir[FR]=frc::SmartDashboard::GetNumber("DB/Slider 1",0)*72;
        ZeroDir[FL]=frc::SmartDashboard::GetNumber("DB/Slider 2",0)*72;
        ZeroDir[RL]=frc::SmartDashboard::GetNumber("DB/Slider 3",0)*72;
        if(ZeroDir[RR]>180) ZeroDir[RR] = (ZeroDir[RR] - 360.0);
        if(ZeroDir[FR]>180) ZeroDir[FR] = (ZeroDir[FR] - 360.0);
        if(ZeroDir[FL]>180) ZeroDir[FL] = (ZeroDir[FL] - 360.0);
        if(ZeroDir[RL]>180) ZeroDir[RL] = (ZeroDir[RL] - 360.0);
        // FLSteer.Set(ControlMode::Position, Arm_Stick.GetX()*ENCODER_RES);
        // RLSteer.Set(ControlMode::Position, Arm_Stick.GetX()*ENCODER_RES);
        // RRSteer.Set(ControlMode::Position, Arm_Stick.GetX()*ENCODER_RES);
       #endif
         SwerveControl(); 
	     SwerveDrive();
         ReadGyro();
         TargetLime();
	     Climber();
         Intake();
         Shooter();
         UpdateDriverScreen(); //@End 
        
        #ifdef PIDTUNE
          //  ConfigPID();
        #endif

         //SetShooterVals();
         hoodPercent=CalcHoodTarget;
        
        
    }

private:

   frc::Joystick Rot_Stick{ROT};
    frc::Joystick Dir_Stick{DIR};
    frc::Joystick Arm_Stick{ARM};

    TalonFX RLDrive = {RLD};
    TalonFX FLDrive = {FLD};
    TalonFX FRDrive = {FRD};
    TalonFX RRDrive = {RRD};
    TalonSRX Intake_Motor = {INTAKE};
    TalonSRX Magazine_Motor = {MAGAZINE};
    TalonFX Shooter_Motor = {SHOOTER};
    TalonSRX Hood_Motor = {HOOD};
    TalonSRX Trigger_Motor = {TRIGGER};
    TalonSRX RLSteer = {RLS};
    TalonSRX RRSteer = {RRS};
    TalonSRX FRSteer = {FRS};
    TalonSRX FLSteer = {FLS};
    TalonSRX Elevator_1 = {EL1};
    TalonSRX Elevator_2 = {EL2};
    TalonSRX Elevator_3 = {EL3};

    frc::Solenoid Intake_Cylinder{frc::PneumaticsModuleType::CTREPCM,0}; //O is intake 
    frc::Solenoid Telescope_Lock{frc::PneumaticsModuleType::CTREPCM,1}; //is Telescoping arm lock
    frc::Solenoid Gearbox_Lock{frc::PneumaticsModuleType::CTREPCM,2}; //gearbox Lock / elevator lock


    frc::Timer ShooterTimer;
    frc::Timer SpinUpTimer;
    frc::Timer HoodResetTimer;
    frc::Timer ClimbTimer;
    frc::Timer AutoTimer;
    frc::Timer TelopTimer;
    frc::Timer TriggerTimer;
    frc::Timer EjectTimer;

    frc::DigitalInput ElevatorBottom{1};      

    
};

#ifndef RUNNING_FRC_TESTS
int main()
{
    return frc::StartRobot<Robot>();
}
#endif

void Robot::RobotInit()
{
    Initialized = 1;
    ahrs = new AHRS(frc::SPI::Port::kMXP);
    Intake_Cylinder.Set(0);
    Telescope_Lock.Set(0);
    Gearbox_Lock.Set(0);
    IntakeIsDown = 0;
    ClimbTimer.Start();
    ClimbTimer.Reset();

    SpinUpTimer.Start();
    SpinUpTimer.Reset();
    ShooterTimer.Start();
    ShooterTimer.Reset();
    HoodResetTimer.Start();
    HoodResetTimer.Reset();
    HoodInitialized=1;
    AutoTimer.Start();
    AutoTimer.Reset();
    TriggerTimer.Start();
  
    
    Hood_Motor.ConfigSelectedFeedbackSensor(FeedbackDevice::PulseWidthEncodedPosition, 0, NOTIMEOUT);	
    Hood_Motor.SetSensorPhase(true);
    Hood_Motor.ConfigNominalOutputForward(0.0f, TIMEOUT);
    Hood_Motor.ConfigNominalOutputReverse(0.0f, TIMEOUT);
    Hood_Motor.ConfigPeakOutputForward(+12.0f, TIMEOUT);
    Hood_Motor.ConfigPeakOutputReverse(-12.0f, TIMEOUT);
    Hood_Motor.SelectProfileSlot(0, 0);
    Hood_Motor.Config_kP(0, 1.0, TIMEOUT);
    Hood_Motor.Config_kI(0, 0.004, TIMEOUT);
    Hood_Motor.Config_kD(0, 0.0, TIMEOUT);
    Hood_Motor.Config_kF(0, 0.0, TIMEOUT);
    Hood_Motor.Set(ControlMode::PercentOutput, 0.5);

    
    Shooter_Motor.ConfigSelectedFeedbackSensor(FeedbackDevice::PulseWidthEncodedPosition);
    Shooter_Motor.SetSensorPhase(true);
    Shooter_Motor.ConfigNominalOutputForward(0.0f, TIMEOUT);
    Shooter_Motor.ConfigNominalOutputReverse(0.0f, TIMEOUT);
    Shooter_Motor.ConfigPeakOutputForward(+12.0f, TIMEOUT);
    Shooter_Motor.ConfigPeakOutputReverse(-12.0f, TIMEOUT);
    Shooter_Motor.SelectProfileSlot(0, 0);
    Shooter_Motor.Config_kP(0, 0.0, TIMEOUT);
    Shooter_Motor.Config_kI(0, 0.0, TIMEOUT);
    Shooter_Motor.Config_kD(0, 0.0, TIMEOUT);
    Shooter_Motor.Config_kF(0, 4.0, TIMEOUT);
    Shooter_Motor.Set(ControlMode::PercentOutput, 0.0);

    Magazine_Motor.ConfigNominalOutputForward(0.0f, TIMEOUT);
    Magazine_Motor.ConfigNominalOutputReverse(0.0f, TIMEOUT);
    Magazine_Motor.ConfigPeakOutputForward(+12.0f, TIMEOUT);
    Magazine_Motor.ConfigPeakOutputReverse(-12.0f, TIMEOUT);
    Magazine_Motor.SelectProfileSlot(0, 0);
    Magazine_Motor.Config_kP(0, 0.5, TIMEOUT);
    Magazine_Motor.Config_kI(0, 0.0, TIMEOUT);
    Magazine_Motor.Config_kD(0, 0.0, TIMEOUT);
    Magazine_Motor.Set(ControlMode::PercentOutput, 0.0);


	    
	    FLSteer.ConfigSelectedFeedbackSensor(FeedbackDevice::PulseWidthEncodedPosition, 0, NOTIMEOUT);
		FLSteer.SetSensorPhase(true);
		FLSteer.ConfigNominalOutputForward(0.0f, TIMEOUT);
		FLSteer.ConfigNominalOutputReverse(0.0f, TIMEOUT);
	   	FLSteer.ConfigPeakOutputForward(+12.0f, TIMEOUT);
	 	FLSteer.ConfigPeakOutputReverse(-12.0f, TIMEOUT);
		FLSteer.SelectProfileSlot(0, 0);
		FLSteer.Config_kP(0, PVALUE, TIMEOUT);
		FLSteer.Config_kI(0, IVALUE, TIMEOUT);
		FLSteer.Config_kD(0, DVALUE, TIMEOUT);
        FLSteer.Config_kF(0, 0.0, TIMEOUT);
        FLSteer.ConfigFeedbackNotContinuous(0,TIMEOUT);
        FLSteer.ConfigClosedloopRamp(.3,TIMEOUT);
       // FLSteer.SetSelectedSensorPosition(0,0,TIMEOUT);
		FLSteer.Set(ControlMode::Position, 0.0);
/*
        FLSteer.configContinuousCurrentLimit(10, 0);
        FLSteer.
        FLSteer.configPeakCurrentLimit(15, 0);
        FLSteer.configPeakCurrentDuration(100, 0);
        FLSteer.enableCurrentLimit(true);
*/
        
        FRSteer.ConfigSelectedFeedbackSensor(FeedbackDevice::PulseWidthEncodedPosition, 0, NOTIMEOUT);	 
		FRSteer.SetSensorPhase(true);
	    FRSteer.ConfigNominalOutputForward(0.0f, TIMEOUT);
		FRSteer.ConfigNominalOutputReverse(0.0f, TIMEOUT);
	    FRSteer.ConfigPeakOutputForward(+12.0f, TIMEOUT);
	 	FRSteer.ConfigPeakOutputReverse(-12.0f, TIMEOUT);
		FRSteer.SelectProfileSlot(0, 0);
		FRSteer.Config_kP(0, PVALUE, TIMEOUT);
		FRSteer.Config_kI(0, IVALUE, TIMEOUT);
		FRSteer.Config_kD(0, DVALUE, TIMEOUT);
        FRSteer.Config_kF(0, 0.0, TIMEOUT);
        FRSteer.ConfigFeedbackNotContinuous(0,TIMEOUT);
		FRSteer.Set(ControlMode::Position, 0.0);
        FRSteer.ConfigClosedloopRamp(.3,TIMEOUT);
      
        RLSteer.ConfigSelectedFeedbackSensor(FeedbackDevice::PulseWidthEncodedPosition, 0, NOTIMEOUT);	
		RLSteer.SetSensorPhase(true);
	    RLSteer.ConfigNominalOutputForward(0.0f, TIMEOUT);
		RLSteer.ConfigNominalOutputReverse(0.0f, TIMEOUT);
	    RLSteer.ConfigPeakOutputForward(+12.0f, TIMEOUT);
	 	RLSteer.ConfigPeakOutputReverse(-12.0f, TIMEOUT);
		RLSteer.SelectProfileSlot(0, 0);
		RLSteer.Config_kP(0, PVALUE, TIMEOUT);
		RLSteer.Config_kI(0, IVALUE, TIMEOUT);
		RLSteer.Config_kD(0, DVALUE, TIMEOUT);
		RLSteer.Config_kF(0, 0.0, TIMEOUT);
        RLSteer.ConfigFeedbackNotContinuous(0,TIMEOUT);
        RLSteer.Set(ControlMode::Position, 0.0);
        RLSteer.ConfigClosedloopRamp(.3,TIMEOUT);
 	    
        RRSteer.ConfigSelectedFeedbackSensor(FeedbackDevice::PulseWidthEncodedPosition, 0, NOTIMEOUT);	 
		RRSteer.SetSensorPhase(true);
	    RRSteer.ConfigNominalOutputForward(0.0f, TIMEOUT);
		RRSteer.ConfigNominalOutputReverse(0.0f, TIMEOUT);
	    RRSteer.ConfigPeakOutputForward(+12.0f, TIMEOUT);
	 	RRSteer.ConfigPeakOutputReverse(-12.0f, TIMEOUT);
		RRSteer.SelectProfileSlot(0, 0);
		RRSteer.Config_kP(0, PVALUE, TIMEOUT);
		RRSteer.Config_kI(0, IVALUE, TIMEOUT);
		RRSteer.Config_kD(0, DVALUE, TIMEOUT);
        RRSteer.Config_kF(0, 0.0, TIMEOUT);
        RRSteer.ConfigFeedbackNotContinuous(0,TIMEOUT);
    	RRSteer.Set(ControlMode::Position, 0.0);
		RRSteer.ConfigClosedloopRamp(.3,TIMEOUT); 


        RLDrive.GetSensorCollection().SetIntegratedSensorPosition(0);
        RLDrive.ConfigSelectedFeedbackSensor(FeedbackDevice::IntegratedSensor, 0, NOTIMEOUT);	 // PIDLoop=0 
		RLDrive.SetSensorPhase(false);
	    RLDrive.ConfigNominalOutputForward(0.0f, TIMEOUT);
		RLDrive.ConfigNominalOutputReverse(0.0f, TIMEOUT);
	    RLDrive.ConfigPeakOutputForward(+12.0f, TIMEOUT);
	 	RLDrive.ConfigPeakOutputReverse(-12.0f, TIMEOUT);
		RLDrive.SelectProfileSlot(0, 0);
		RLDrive.Config_kP(0, 0.5, TIMEOUT);
		RLDrive.Config_kI(0, 0.0, TIMEOUT);
		RLDrive.Config_kD(0, 0.0, TIMEOUT);
		RLDrive.Set(ControlMode::Position, 0.0);
        RLDrive.ConfigClosedloopRamp(.3,TIMEOUT);

		RRDrive.GetSensorCollection().SetIntegratedSensorPosition(0);
        RRDrive.ConfigSelectedFeedbackSensor(FeedbackDevice::IntegratedSensor, 0, NOTIMEOUT);	 
		RRDrive.SetSensorPhase(false);
	    RRDrive.ConfigNominalOutputForward(0.0f, TIMEOUT);
		RRDrive.ConfigNominalOutputReverse(0.0f, TIMEOUT);
	    RRDrive.ConfigPeakOutputForward(+12.0f, TIMEOUT);
	 	RRDrive.ConfigPeakOutputReverse(-12.0f, TIMEOUT);
		RRDrive.SelectProfileSlot(0, 0);
		RRDrive.Config_kP(0, 0.5, TIMEOUT);
		RRDrive.Config_kI(0, 0.0, TIMEOUT);
		RRDrive.Config_kD(0, 0.0, TIMEOUT);
		RRDrive.Set(ControlMode::Position, 0.0);
        RRDrive.ConfigClosedloopRamp(.3,TIMEOUT);

        FRDrive.GetSensorCollection().SetIntegratedSensorPosition(0);
        FRDrive.ConfigSelectedFeedbackSensor(FeedbackDevice::IntegratedSensor, 0, NOTIMEOUT);	 
		FRDrive.SetSensorPhase(false);
	    FRDrive.ConfigNominalOutputForward(0.0f, TIMEOUT);
		FRDrive.ConfigNominalOutputReverse(0.0f, TIMEOUT);
	    FRDrive.ConfigPeakOutputForward(+12.0f, TIMEOUT);
	 	FRDrive.ConfigPeakOutputReverse(-12.0f, TIMEOUT);
		FRDrive.SelectProfileSlot(0, 0);
		FRDrive.Config_kP(0, 0.5, TIMEOUT);
		FRDrive.Config_kI(0, 0.0, TIMEOUT);
		FRDrive.Config_kD(0, 0.0, TIMEOUT);
		FRDrive.Set(ControlMode::Position, 0.0);
        FRDrive.ConfigClosedloopRamp(.3,TIMEOUT);

		FLDrive.GetSensorCollection().SetIntegratedSensorPosition(0);
        FLDrive.ConfigSelectedFeedbackSensor(FeedbackDevice::IntegratedSensor, 0, NOTIMEOUT);	
		FLDrive.SetSensorPhase(false);
	    FLDrive.ConfigNominalOutputForward(0.0f, TIMEOUT);
		FLDrive.ConfigNominalOutputReverse(0.0f, TIMEOUT);
	    FLDrive.ConfigPeakOutputForward(+12.0f, TIMEOUT);
	 	FLDrive.ConfigPeakOutputReverse(-12.0f, TIMEOUT);
		FLDrive.SelectProfileSlot(0, 0);
		FLDrive.Config_kP(0, 0.5, TIMEOUT);
		FLDrive.Config_kI(0, 0.0, TIMEOUT);
		FLDrive.Config_kD(0, 0.0, TIMEOUT);
		FLDrive.Set(ControlMode::Position, 0.0);
        FLDrive.ConfigClosedloopRamp(.3,TIMEOUT);

        //CLimber
        Elevator_1.ConfigSelectedFeedbackSensor(FeedbackDevice::PulseWidthEncodedPosition, 0, NOTIMEOUT);
        Elevator_1.SetSensorPhase(true);
	    Elevator_1.ConfigNominalOutputForward(0.0f, TIMEOUT);
		Elevator_1.ConfigNominalOutputReverse(0.0f, TIMEOUT);
	    Elevator_1.ConfigPeakOutputForward(+12.0f, TIMEOUT);
	 	Elevator_1.ConfigPeakOutputReverse(-12.0f, TIMEOUT);
		Elevator_1.SelectProfileSlot(0, 0);
		Elevator_1.Config_kP(0, PVALUE, TIMEOUT);
		Elevator_1.Config_kI(0, 0.0, TIMEOUT);
		Elevator_1.Config_kD(0, 0.0, TIMEOUT);
		Elevator_1.Config_kF(0, 0.0, TIMEOUT);


        Elevator_2.ConfigSelectedFeedbackSensor(FeedbackDevice::PulseWidthEncodedPosition, 0, NOTIMEOUT);	
		Elevator_2.SetSensorPhase(true);
	    Elevator_2.ConfigNominalOutputForward(0.0f, TIMEOUT);
		Elevator_2.ConfigNominalOutputReverse(0.0f, TIMEOUT);
	    Elevator_2.ConfigPeakOutputForward(+12.0f, TIMEOUT);
	 	Elevator_2.ConfigPeakOutputReverse(-12.0f, TIMEOUT);
		Elevator_2.SelectProfileSlot(0, 0);
		Elevator_2.Config_kP(0, PVALUE, TIMEOUT);
		Elevator_2.Config_kI(0, 0.0, TIMEOUT);
		Elevator_2.Config_kD(0, 0.0, TIMEOUT);
		Elevator_2.Config_kF(0, 0.0, TIMEOUT);
        Elevator_2.Set(ControlMode::Position, 0.0);

        Elevator_3.ConfigSelectedFeedbackSensor(FeedbackDevice::PulseWidthEncodedPosition, 0, NOTIMEOUT);	
		Elevator_3.SetSensorPhase(true);
	    Elevator_3.ConfigNominalOutputForward(0.0f, TIMEOUT);
		Elevator_3.ConfigNominalOutputReverse(0.0f, TIMEOUT);
	    Elevator_3.ConfigPeakOutputForward(+12.0f, TIMEOUT);
	 	Elevator_3.ConfigPeakOutputReverse(-12.0f, TIMEOUT);
		Elevator_3.SelectProfileSlot(0, 0);
		Elevator_3.Config_kP(0, PVALUE, TIMEOUT);
		Elevator_3.Config_kI(0, 0.0, TIMEOUT);
		Elevator_3.Config_kD(0, 0.0, TIMEOUT);
		Elevator_3.Config_kF(0, 0.0, TIMEOUT);
        Elevator_3.Set(ControlMode::Position, 0.0);

        ElevatorZero = Elevator_1.GetSensorCollection().GetPulseWidthPosition();


    //Color Sensor
    m_colorMatcher.AddColorMatch(kBlueTarget);
    m_colorMatcher.AddColorMatch(kRedTarget);

    //Getting Alliance and location
    Alliance = frc::DriverStation::GetAlliance();
    //StartingLocation = frc::DriverStation::GetAlliance()*10 + frc::DriverStation::GetLocation();
    StartingLocation = 0; //frc::SmartDashboard::GetNumber("DB/Slider 0",-1);
    ResetGyro();
  
}